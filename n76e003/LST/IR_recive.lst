C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/28/2017 16:46:12 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE IR_RECIVE
OBJECT MODULE PLACED IN .\Output\IR_recive.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Common\IR_recive.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Include;.\Include)
                    - DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\IR_recive.lst) TABS(2) OBJECT(.\Output\IR_recive.obj)

line level    source

   1          #include "IR_recive.h"
   2          
   3          
   4          #include "N76E003.h"
   5          #include "Common.h"
   6          #include "Delay.h"
   7          #include "SFR_Macro.h"
   8          #include "Function_define.h"
   9          
  10          /********ms***********/
  11          #define First_Boot_code       8
  12          #define Second_Boot_code      4
  13          #define Data_0_1_code         1
  14          #define Stop_code             40
  15          
  16          #define Data_count            0x04        
  17          
  18          #define ir_pin                P03
  19          #define Key_count             14
  20          
  21          UINT8 dat[Data_count]={0},key_press=0;
  22          bit Recive_flag=0;
  23          
  24          extern  void  NPCA110P_SOURCE(void);
  25          extern  void  NPCA110P_MODE(void);
  26          extern  void  NPCA110P_VOL_A(void);
  27          extern  void  NPCA110P_VOL_B(void);
  28          extern  void  NPCA110P_MUTE(void);
  29          extern  void  GPIO_MUTE(void);
  30          extern  bit power_flag,led_flag;
  31          
  32          void dat_clr(void);
  33          
  34          void IR_init(void)
  35          {
  36   1          P03_Input_Mode;
  37   1          P03 = 1;
  38   1          Enable_BIT3_LowLevel_Trig;
  39   1          set_EPI;              // Enable pin interrupt
  40   1      }
  41          
  42          
  43          
  44          void PinInterrupt_ISR (void) interrupt 7
  45          {
  46   1        UINT8 i=0,j=0,n=0;
  47   1        if(PIF & 0x08)
  48   1        {
  49   2          PIF =PIF & 0xf7;                             //clear interrupt flag
  50   2          clr_EPI;
  51   2          i++;
  52   2          do//9ms low
  53   2          {
  54   3            n++;
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/28/2017 16:46:12 PAGE 2   

  55   3            Timer1_Delay1ms(1);
  56   3          }while(!ir_pin);
  57   2          if(n<First_Boot_code)//没有达到8ms low
  58   2          {
  59   3      //      dat_clr();
  60   3            set_EPI;
  61   3            return;
  62   3          }
  63   2          n=0;
  64   2          
  65   2          do//4ms high or 2ms high
  66   2          {
  67   3            n++;
  68   3            Timer1_Delay1ms(1);
  69   3            if((!ir_pin)&&(n<Second_Boot_code))//2ms  high
  70   3              {
  71   4                  dat_clr();
  72   4                  set_EPI;
  73   4                  return;
  74   4              }
  75   3          }while(ir_pin);
  76   2          n=0;
  77   2          
  78   2          for(i=0;i<Data_count;i++)             //32bit数据码
  79   2          {
  80   3              for(j=0;j<8;j++)
  81   3              {
  82   4                  while(!ir_pin);                 //0.56ms  low
  83   4                
  84   4                  Timer1_Delay1ms(Data_0_1_code);
  85   4                  if(ir_pin)                        //数据 1  high
  86   4                  {
  87   5                      dat[i] >>= 1;
  88   5                      dat[i] |= 0x80;
  89   5                      while(ir_pin);
  90   5                  }
  91   4                  else                          //数据 0  high
  92   4                  {
  93   5                      dat[i] >>= 1;
  94   5                  }
  95   4              }
  96   3              
  97   3          }
  98   2            
  99   2          while(!ir_pin);                         //0.56ms  low
 100   2          
 101   2          do//40ms  high
 102   2          {
 103   3            n++;
 104   3            Timer1_Delay1ms(1);
 105   3              if(n>30)//20ms  high
 106   3              {
 107   4                n=0;
 108   4                Data_Check();
 109   4                dat_clr();
 110   4                Timer1_Delay1ms(40);
 111   4                set_EPI;
 112   4                return;
 113   4              }
 114   3          }while(ir_pin);
 115   2      //    Data_Check();
 116   2          dat_clr();
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/28/2017 16:46:12 PAGE 3   

 117   2          set_EPI;
 118   2          return;
 119   2          #if 0
              //    while(ir_pin);  
                  set_GPIO1;
                  Data_Check();
                  Timer1_Delay1ms(2);                 //delay2ms
                  
                  for(i=0;i<First_Boot_code-2;i++)        
                  {
                      Timer1_Delay1ms(1);
                      if(ir_pin)
                      {
                          dat_clr();
                          set_EPI;
                          return;
                      }
                  }
                  while(!ir_pin);                         //8ms   low
              
              //    for(i=0;i<Second_Boot_code;i++)       
              //    {
              //        Timer1_Delay1ms(1);
              //        if(!ir_pin)
              //        {
              //            dat_clr();
              //            set_EX1;
              //            return;
              //        }
              //    }
                  while(ir_pin);                            //2ms   high
                  
                  while(!ir_pin);                         //0.56ms  low
              //    Timer1_Delay1ms(2000);                  //delay2ms
              //    while(ir_pin);
                  
                  dat_clr();
                  set_EPI;
                  return;
                  #endif    
 157   2        }
 158   1        else
 159   1        {
 160   2          PIF = 0x00;                             //clear interrupt flag
 161   2        }
 162   1      }
 163          
 164          
 165          
 166          void Data_Check(void)
 167          {
 168   1          if(dat[2] == ~dat[3])
 169   1          {
 170   2              key_press = dat[2];
 171   2              dat_clr();
 172   2              Recive_flag = 1;
 173   2          }
 174   1          else
 175   1          {
 176   2              key_press = 0;
 177   2              Recive_flag = 0;
 178   2          }
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/28/2017 16:46:12 PAGE 4   

 179   1      }
 180          
 181          void dat_clr(void)
 182          {
 183   1          UINT8 i;    
 184   1          for(i=0;i<Data_count;i++)
 185   1          {
 186   2              dat[i] = 0;
 187   2          }   
 188   1      }
 189          
 190          void IR_Deal(void)
 191          {
 192   1        if(Recive_flag)
 193   1        {
 194   2          switch(key_press)//switch(ir.dat.data0)
 195   2          {
 196   3            case  0x01:       //BASS+
 197   3              break;
 198   3            case  0x02:       //BASS-
 199   3              break;
 200   3            case  0x03:       //TREBLE+
 201   3              break;
 202   3            case  0x04:       //TREBLE-
 203   3              break;
 204   3            case  0x0a:       //LINE IN
 205   3              break;
 206   3            case  0x0b:       //AUX IN
 207   3              break;
 208   3            case  0x0c:       //BLUETOOTH
 209   3      //      if()
 210   3              break;
 211   3            case  0x0d:       //OPTICAL
 212   3            if(ST_BY)
 213   3            {
 214   4              NPCA110P_SOURCE();
 215   4              led_flag = 1;
 216   4            }
 217   3              break;
 218   3            case  0x0e:       //COAXIAL
 219   3            if(ST_BY) 
 220   3            {
 221   4              NPCA110P_MODE();
 222   4              led_flag = 1;
 223   4            }
 224   3              break;
 225   3            case  0x12:       //VOL+
 226   3            if(ST_BY)
 227   3            {
 228   4              NPCA110P_VOL_A();
 229   4              led_flag = 1;
 230   4            }
 231   3              break;
 232   3            case  0x13:       //VOL-
 233   3            if(ST_BY)
 234   3            {
 235   4              NPCA110P_VOL_B();
 236   4              led_flag = 1;
 237   4            }
 238   3              break;
 239   3            case  0x14:       //ON-OFF
 240   3            {
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/28/2017 16:46:12 PAGE 5   

 241   4              power_flag = ~power_flag;
 242   4              break;
 243   4            }
 244   3            case  0x15:       //MUTE
 245   3            if(ST_BY)
 246   3            {
 247   4      //        NPCA110P_MUTE();
 248   4              GPIO_MUTE();
 249   4            }
 250   3              break;
 251   3            case  0x18:       //HDMI
 252   3              break;
 253   3            default:
 254   3              break;
 255   3          }
 256   2          Recive_flag = 0;
 257   2        }
 258   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    417    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
