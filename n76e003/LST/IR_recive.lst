C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/29/2017 17:20:15 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE IR_RECIVE
OBJECT MODULE PLACED IN .\Output\IR_recive.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Common\IR_recive.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Include;.\Include)
                    - DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\IR_recive.lst) TABS(2) OBJECT(.\Output\IR_recive.obj)

line level    source

   1          #include "IR_recive.h"
   2          #include "config.h"
   3          
   4          #include "N76E003.h"
   5          #include "Common.h"
   6          //#include "Delay.h"
   7          #include "SFR_Macro.h"
   8          #include "Function_define.h"
   9          
  10          /********ms***********/
  11          #define First_Boot_code       8
  12          #define Second_Boot_code      4
  13          #define Data_0_1_code         1
  14          #define Stop_code             40
  15          
  16          #define Data_count            0x04        
  17          
  18          #define ir_pin                P03
  19          #define Key_count             14
  20          
  21          //#define   ir_play           0x01
  22          //#define   ir_fwd            0x02
  23          //#define   ir_rev            0x03
  24          //#define   ir_hall           0x04
  25          //#define   ir_music          0x05
  26          //#define   ir_speech         0x06
  27          //#define   ir_mute           0x07
  28          //#define   ir_volA           0x20
  29          //#define   ir_volB           0x30
  30          //#define   ir_source         0x40
  31          //#define   ir_power          0xf0
  32          //#define   ir_play           0x10
  33          
  34          UINT8 dat[Data_count]={0},key_press=0;
  35          bit Recive_flag=0;
  36          
  37          extern  void Timer1_Delay1ms(UINT32 u32CNT);
  38          extern  void  NPCA110P_SOURCE(void);
  39          extern  void  NPCA110P_MODE(void);
  40          extern  void  NPCA110P_VOL_A(void);
  41          extern  void  NPCA110P_VOL_B(void);
  42          extern  void  NPCA110P_MUTE(void);
  43          extern  void  GPIO_MUTE(void);
  44          extern  bit power_flag,led_flag;
  45          
  46          extern  void BT_Play_Pause(void); 
  47          extern  void BT_REV_TASK(void); 
  48          extern  void BT_FWD_TASK(void); 
  49          
  50          extern  UINT8 KEY_VALUE;
  51          extern  UINT8 mode_in;
  52          extern  UINT8   key_flag;
  53          
  54          void dat_clr(void);
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/29/2017 17:20:15 PAGE 2   

  55          
  56          void IR_init(void)
  57          {
  58   1          P03_Input_Mode;
  59   1          P03 = 1;
  60   1          Enable_BIT3_LowLevel_Trig;
  61   1          set_EPI;              // Enable pin interrupt
  62   1      }
  63          
  64          
  65          
  66          void PinInterrupt_ISR (void) interrupt 7
  67          {
  68   1        UINT8 i=0,j=0,n11=0;
  69   1        if(PIF & 0x08)
  70   1        {
  71   2          PIF =PIF & 0xf7;                             //clear interrupt flag
  72   2          clr_EPI;
  73   2          i++;
  74   2          do//9ms low
  75   2          {
  76   3            n11++;
  77   3            Timer1_Delay1ms(1);
  78   3          }while(!ir_pin);
  79   2      //    if(n<First_Boot_code)//没有达到8ms low
  80   2      //    {
  81   2      ////      dat_clr();
  82   2      //      set_EPI;
  83   2      //      return;
  84   2      //    }
  85   2          n11=0;
  86   2          
  87   2          do//4ms high or 2ms high
  88   2          {
  89   3            n11++;
  90   3            Timer1_Delay1ms(1);
  91   3      //      if((!ir_pin)&&(n<Second_Boot_code))//2ms  high
  92   3      //        {
  93   3      //            dat_clr();
  94   3      //            set_EPI;
  95   3      //            return;
  96   3      //        }
  97   3          }while(ir_pin);
  98   2          n11=0;
  99   2          
 100   2          for(i=0;i<Data_count;i++)             //32bit数据码
 101   2          {
 102   3              for(j=0;j<8;j++)
 103   3              {
 104   4                  while(!ir_pin);                 //0.56ms  low
 105   4                
 106   4                  Timer1_Delay1ms(Data_0_1_code);
 107   4                  if(ir_pin)                        //数据 1  high
 108   4                  {
 109   5                      dat[i] >>= 1;
 110   5                      dat[i] |= 0x80;
 111   5                      while(ir_pin);
 112   5                  }
 113   4                  else                          //数据 0  high
 114   4                  {
 115   5                      dat[i] >>= 1;
 116   5                  }
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/29/2017 17:20:15 PAGE 3   

 117   4              }
 118   3              
 119   3          }
 120   2            
 121   2          while(!ir_pin);                         //0.56ms  low
 122   2      //    do//40ms  high
 123   2      //    {
 124   2      //      n11++;
 125   2      //      Timer1_Delay1ms(1);
 126   2      ////        if(n>30)//20ms  high
 127   2      ////        {
 128   2      ////          n=0;
 129   2      ////          Data_Check();
 130   2      ////          dat_clr();
 131   2      //////          Timer1_Delay1ms(100);
 132   2      ////          set_EPI;
 133   2      ////          return;
 134   2      ////        }
 135   2      //    }while(ir_pin);
 136   2          Data_Check();
 137   2          Timer1_Delay1ms(30);    
 138   2          dat_clr();
 139   2          set_EPI;
 140   2          return;
 141   2          #if 0
              //    while(ir_pin);  
                  set_GPIO1;
                  Data_Check();
                  Timer1_Delay1ms(2);                 //delay2ms
                  
                  for(i=0;i<First_Boot_code-2;i++)        
                  {
                      Timer1_Delay1ms(1);
                      if(ir_pin)
                      {
                          dat_clr();
                          set_EPI;
                          return;
                      }
                  }
                  while(!ir_pin);                         //8ms   low
              
              //    for(i=0;i<Second_Boot_code;i++)       
              //    {
              //        Timer1_Delay1ms(1);
              //        if(!ir_pin)
              //        {
              //            dat_clr();
              //            set_EX1;
              //            return;
              //        }
              //    }
                  while(ir_pin);                            //2ms   high
                  
                  while(!ir_pin);                         //0.56ms  low
              //    Timer1_Delay1ms(2000);                  //delay2ms
              //    while(ir_pin);
                  
                  dat_clr();
                  set_EPI;
                  return;
                  #endif    
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/29/2017 17:20:15 PAGE 4   

 179   2        }
 180   1        else
 181   1        {
 182   2          PIF = 0x00;                             //clear interrupt flag
 183   2        }
 184   1      }
 185          
 186          
 187          
 188          void Data_Check(void)
 189          {
 190   1          if(dat[2] == ~dat[3])
 191   1          {
 192   2              key_press = dat[2];
 193   2              dat_clr();
 194   2              Recive_flag = 1;
 195   2          }
 196   1          else
 197   1          {
 198   2              key_press = 0;
 199   2              Recive_flag = 0;
 200   2          }
 201   1      }
 202          
 203          void dat_clr(void)
 204          {
 205   1          UINT8 i;    
 206   1          for(i=0;i<Data_count;i++)
 207   1          {
 208   2              dat[i] = 0;
 209   2          }   
 210   1      }
 211          
 212          void IR_Deal(void)
 213          {
 214   1        UINT8 mod=0;
 215   1        if(Recive_flag)
 216   1        {
 217   2          switch(key_press)//switch(ir.dat.data0)
 218   2          {
 219   3            case  0x10:       //PLAY
 220   3              KEY_VALUE = ir_play;
 221   3              key_flag = 0x80;
 222   3            break;
 223   3            case  0x11:       //FWD
 224   3              KEY_VALUE = ir_fwd;
 225   3              key_flag = 0x80;
 226   3              break;
 227   3            case  0x16:       //REV
 228   3              key_flag = 0x80;
 229   3              KEY_VALUE = ir_rev;
 230   3              break;
 231   3            case  0x04:       //TREBLE-
 232   3              break;
 233   3            case  0x0a:       //LINE IN
 234   3              break;
 235   3            case  0x0b:       //AUX IN
 236   3              break;
 237   3            case  0x0c:       //BLUETOOTH
 238   3              break;
 239   3            case  0x41:       //SOURCE
 240   3              key_flag = 0x80;
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/29/2017 17:20:15 PAGE 5   

 241   3              KEY_VALUE = ir_source;
 242   3              break;
 243   3            case  0x4a:       //HALL
 244   3              key_flag = 0x80;
 245   3              KEY_VALUE = ir_hall;
 246   3              break;
 247   3            case  0x4b:       //MUSIC
 248   3              key_flag = 0x80;
 249   3              KEY_VALUE = ir_music;
 250   3              break;
 251   3            case  0x4c:       //SPEECH
 252   3              key_flag = 0x80;
 253   3              KEY_VALUE = ir_speech;
 254   3              break;
 255   3            case  0x12:       //VOL+
 256   3              key_flag = 0x80;
 257   3              KEY_VALUE = ir_volA;
 258   3              break;
 259   3            case  0x13:       //VOL-
 260   3              key_flag = 0x80;
 261   3              KEY_VALUE = ir_volB;
 262   3              break;
 263   3            case  0x14:       //ON-OFF
 264   3              key_flag = 0x80;
 265   3              KEY_VALUE = ir_power;
 266   3              break;
 267   3            case  0x15:       //MUTE
 268   3              key_flag = 0x80;
 269   3              KEY_VALUE = ir_mute;
 270   3              break;
 271   3            case  0x18:       //HDMI
 272   3              break;
 273   3            default:
 274   3              break;
 275   3          }
 276   2          Recive_flag = 0;
 277   2        }
 278   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    419    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
