C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/21/2017 12:00:31 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE IR_RECIVE
OBJECT MODULE PLACED IN .\Output\IR_recive.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE Common\IR_recive.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Include;.\Include)
                    - DEFINE(FOSC_160000) DEBUG OBJECTEXTEND PRINT(.\LST\IR_recive.lst) TABS(2) OBJECT(.\Output\IR_recive.obj)

line level    source

   1          #include "IR_recive.h"
   2          
   3          
   4          #include "N76E003.h"
   5          #include "Common.h"
   6          #include "Delay.h"
   7          #include "SFR_Macro.h"
   8          #include "Function_define.h"
   9          
  10          /********ms***********/
  11          #define First_Boot_code       8
  12          #define Second_Boot_code      4
  13          #define Data_0_1_code         1
  14          #define Stop_code             40
  15          
  16          #define Data_count            0x04        
  17          
  18          #define ir_pin                P03
  19          #define Key_count             14
  20          
  21          UINT8 dat[Data_count]={0},key_press=0;
  22          bit Recive_flag=0;
  23          
  24          extern  void  NPCA110P_SOURCE(void);
  25          extern  void  NPCA110P_VOL_A(void);
  26          extern  void  NPCA110P_VOL_B(void);
  27          extern  void  NPCA110P_MUTE(void);
  28          extern  void  GPIO_MUTE(void);
  29          extern  bit power_flag,led_flag;
  30          
  31          void IR_init(void)
  32          {
  33   1          P03_Input_Mode;
  34   1          P03 = 1;
  35   1          Enable_BIT3_LowLevel_Trig;
  36   1          set_EPI;              // Enable pin interrupt
  37   1      }
  38          
  39          
  40          
  41          void PinInterrupt_ISR (void) interrupt 7
  42          {
  43   1        UINT8 i=0,j=0;
  44   1        if(PIF & 0x08)
  45   1        {
  46   2          PIF =PIF & 0xf7;                             //clear interrupt flag
  47   2        #if 1
  48   2          clr_EPI;
  49   2      //    clr_GPIO1;                                //亮指示灯
  50   2          for(i=0;i<First_Boot_code;i++)            //8ms low
  51   2          {
  52   3              Timer1_Delay1ms(1);
  53   3              if(ir_pin)
  54   3              {
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/21/2017 12:00:31 PAGE 2   

  55   4                  dat_clr();
  56   4                  set_EPI;
  57   4                  return;
  58   4              }
  59   3          }
  60   2          while(!ir_pin);
  61   2      
  62   2          for(i=0;i<Second_Boot_code;i++)           //4ms high
  63   2          {
  64   3              Timer1_Delay1ms(1);
  65   3              if(!ir_pin)
  66   3              {
  67   4                  dat_clr();
  68   4                  set_EPI;
  69   4                  return;
  70   4              }
  71   3          }
  72   2          while(ir_pin);
  73   2        
  74   2          for(i=0;i<Data_count;i++)             //32bit数据码
  75   2          {
  76   3              for(j=0;j<8;j++)
  77   3              {
  78   4                  while(!ir_pin);                 //0.56ms  low
  79   4                
  80   4                  Timer1_Delay1ms(Data_0_1_code);
  81   4                  if(ir_pin)                        //数据 1  high
  82   4                  {
  83   5                      dat[i] >>= 1;
  84   5                      dat[i] |= 0x80;
  85   5                      while(ir_pin);
  86   5                  }
  87   4                  else                          //数据 0  high
  88   4                  {
  89   5                      dat[i] >>= 1;
  90   5                  }
  91   4              }
  92   3              
  93   3          }
  94   2            
  95   2          while(!ir_pin);                         //0.56ms  low
  96   2          
  97   2          for(i=0;i<Stop_code;i++)          //40ms    high
  98   2          {
  99   3              Timer1_Delay1ms(1);
 100   3              if(!ir_pin)
 101   3              {
 102   4                dat_clr();
 103   4                set_EPI;
 104   4                return;
 105   4              }
 106   3          }
 107   2      //    while(ir_pin);  
 108   2          set_GPIO1;
 109   2          Data_Check();
 110   2          Timer1_Delay1ms(2);                 //delay2ms
 111   2          
 112   2          for(i=0;i<First_Boot_code-2;i++)        
 113   2          {
 114   3              Timer1_Delay1ms(1);
 115   3              if(ir_pin)
 116   3              {
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/21/2017 12:00:31 PAGE 3   

 117   4                  dat_clr();
 118   4                  set_EPI;
 119   4                  return;
 120   4              }
 121   3          }
 122   2          while(!ir_pin);                         //8ms   low
 123   2      
 124   2      //    for(i=0;i<Second_Boot_code;i++)       
 125   2      //    {
 126   2      //        Timer1_Delay1ms(1);
 127   2      //        if(!ir_pin)
 128   2      //        {
 129   2      //            dat_clr();
 130   2      //            set_EX1;
 131   2      //            return;
 132   2      //        }
 133   2      //    }
 134   2          while(ir_pin);                            //2ms   high
 135   2          
 136   2          while(!ir_pin);                         //0.56ms  low
 137   2      //    Timer1_Delay1ms(2000);                  //delay2ms
 138   2      //    while(ir_pin);
 139   2          
 140   2          dat_clr();
 141   2          set_EPI;
 142   2          return;
 143   2          #endif    
 144   2        }
 145   1        else
 146   1        {
 147   2          PIF = 0x00;                             //clear interrupt flag
 148   2        }
 149   1      }
 150          
 151          
 152          
 153          void Data_Check(void)
 154          {
 155   1          if(dat[2] == ~dat[3])
 156   1          {
 157   2              key_press = dat[2];
 158   2              dat_clr();
 159   2              Recive_flag = 1;
 160   2          }
 161   1          else
 162   1          {
 163   2              key_press = 0;
 164   2              Recive_flag = 0;
 165   2          }
 166   1      }
 167          
 168          void dat_clr(void)
 169          {
 170   1          UINT8 i;    
 171   1          for(i=0;i<Data_count;i++)
 172   1          {
 173   2              dat[i] = 0;
 174   2          }   
 175   1      }
 176          
 177          void IR_Deal(void)
 178          {
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/21/2017 12:00:31 PAGE 4   

 179   1        if(Recive_flag)
 180   1        {
 181   2          switch(key_press)//switch(ir.dat.data0)
 182   2          {
 183   3            case  0x01:       //BASS+
 184   3              break;
 185   3            case  0x02:       //BASS-
 186   3              break;
 187   3            case  0x03:       //TREBLE+
 188   3              break;
 189   3            case  0x04:       //TREBLE-
 190   3              break;
 191   3            case  0x0a:       //LINE IN
 192   3              break;
 193   3            case  0x0b:       //AUX IN
 194   3              break;
 195   3            case  0x0c:       //BLUETOOTH
 196   3              break;
 197   3            case  0x0d:       //OPTICAL
 198   3            {
 199   4              NPCA110P_SOURCE();
 200   4              led_flag = 1;
 201   4              break;
 202   4            }
 203   3            case  0x0e:       //COAXIAL
 204   3              break;
 205   3            case  0x12:       //VOL+
 206   3            {
 207   4              NPCA110P_VOL_A();
 208   4              break;
 209   4            }
 210   3            case  0x13:       //VOL-
 211   3            {
 212   4              NPCA110P_VOL_B();
 213   4              break;
 214   4            }
 215   3            case  0x14:       //ON-OFF
 216   3            {
 217   4              power_flag = ~power_flag;
 218   4              break;
 219   4            }
 220   3            case  0x15:       //MUTE
 221   3            {
 222   4      //        NPCA110P_MUTE();
 223   4              GPIO_MUTE();
 224   4              break;
 225   4            }
 226   3            case  0x18:       //HDMI
 227   3              break;
 228   3            default:
 229   3              break;
 230   3          }
 231   2          Recive_flag = 0;
 232   2        }
 233   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    419    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.56.0.0   IR_RECIVE                                                         12/21/2017 12:00:31 PAGE 5   

   DATA SIZE        =      5       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
